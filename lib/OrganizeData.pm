package lib::OrganizeData;

#-------------------------------------------------------------------------------
#   This package holds the file operations like
#       * moving double files to a new common folder
#       * remove double files
#       * replace double files with shortcuts
#-------------------------------------------------------------------------------

use strict;
use warnings;
use 5.24.0;

use Path::Tiny;
use Win32::Shortcut;

use Data::Dumper;

require Exporter;

our @ISA = qw ( Exporter );

our @EXPORT = qw (
	loop_data
	);

# TODO: Establish error handling for file operations: copy, remove
# TODO: Insert simulation mode so that all file operations can be savely tested

#-------------------------------------------------------------------------------
#   Loop through a data structure which was generated by a folder/file scan and
#   holds information about the found files.
#
sub loop_data {
	my $data = shift;       # data structure holding the result of a folder scan
	my $target = shift;     # path info to the common folder double files will
							# be moved to
	foreach my $key ( keys %$data ) {
		if (scalar @{$data->{$key}} > 1) {
			say scalar@{$data->{$key}} . ' mal: ' . path($data->{$key}->[0]->[0])->basename;
			foreach my $double ( $data->{$key} ) {
				my $cnt = 0;
				foreach my $entry ( @$double ) {
					my $target_filename = make_filename( $entry->[0], $entry->[6] );

					if ($cnt == 0 ) {   # only the first loop copies the file
						copy_file( $entry->[0], $target_filename, $target );
						create_shortcut( $entry->[0], $target_filename, $target );
						remove_file( $entry->[0] );
						$cnt ++;
					}
					else {              # all other only create shortcuts
						create_shortcut( $entry->[0], $target );
						remove_file( $entry->[0] );
					}
				}
				print "\n";
			}
		}
	}
}

#-------------------------------------------------------------------------------
#   Copy original to common folder
#
sub copy_file {
	my $source = shift;         # path and filename of the original file
	my $target_file = shift;    # filename consisting of filename + MD5 checksum
	my $target = shift;         # path to new collective directory

	my $newpath = path($target)->child($target_file);

	say "copy from: " . $source;
	say "copy to  : " . $newpath;

	path($source)->copy($newpath);
}

#-------------------------------------------------------------------------------
#   Removes the file
#
sub remove_file {
	my $file = shift;

	say "remove: $file";

	# TODO: Activate the following line after sufficient testing
	#path($file)->remove;
}

#-------------------------------------------------------------------------------
#   Creates a shortcut in the directory from which the original file will be
#   removed.
#
sub create_shortcut {
	my $path = shift;           # path and filename of the original file which will be moved
	my $target_file = shift;    # filename consisting of filename + MD5 checksum
	my $target_path = shift;    # path to the destination folder

	# The filename of the original file which provides the name of the short-
	# cut later on
	my $file_name = path($path)->basename;

	# The path to the original folder without the filename. The path is needed to
	# store the shortcut in the original folder.
	my $dir_name = path($path)->parent;

	# Add the 'lnk' extension to the original filename so that the shortcut has
	# the same name as the original file
	my $shortcut_name = $file_name . '.lnk';

	# Add the name of the shortcut to the path to the original folder, so that
	# the shortcut is stored there
	my $shortcut_path = path($dir_name)->child($shortcut_name);

	my $LINK = Win32::Shortcut->new();

	# Add the path to the single file which is now in the common folder as a
	# target of the shortcut
	$LINK->{'Path'} = path($target_path)->child($target_file);
	say "Path to the common file: " . path($target_path)->child($target_file);

	# Define the path where the shortcut shall be stored. That is the location
	# where the original file is deleted respectively moved to the common folder
	$LINK->Save($shortcut_path);
	say "Path and name of link  : " . $shortcut_path;

	# By closing the shortcut the process of creating it is finished
	$LINK->Close();
}

#-------------------------------------------------------------------------------
#   Since it is possible to have double filenames with different MD5 sums which
#   have to be copied into a common folder the new filename will be combined
#   from the filename plus the MD checksum e.g.:
#       old name: my_file.txt
#       new name: my_file_0f8ed58339fa224772b43b8925bd955e.txt
#
sub make_filename {
	my $path = shift;   # path and filename of the to be copied file
	my $md5 = shift;    # MD5 checksum of the to be copied file

	# split filename at '.' to get the extension
	my @filecomponents = split ( /\./, path($path)->basename);

	my $filename;
	my $extension;

	if ( scalar @filecomponents > 1 ) {     # file has an extension
		$extension = pop @filecomponents;   # last element in arry is extension
		$filename = join '.', @filecomponents;  # recombine filename
		$filename = $filename . '_' . $md5 . '.' . $extension;
	}
	else {                                  # file doesn't have an extension
		$filename = $filecomponents[0] . '_' . $md5;
	}

	return $filename;
}

1;