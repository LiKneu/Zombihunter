package lib::OrganizeData;

#-------------------------------------------------------------------------------
#   This package holds the file operations like
#       * moving double files to a new common folder
#       * remove double files
#       * replace double files with shortcuts
#-------------------------------------------------------------------------------

use strict;
use warnings;
use 5.24.0;

use Path::Tiny;
use Win32::Shortcut;

use lib::ScanFolders;

require Exporter;

our @ISA = qw ( Exporter );

our @EXPORT = qw (
	loop_data
	);

my $org_log_fh; # file handle to output error messages

# TODO: Insert simulation mode so that all file operations can be savely tested
# TODO: Before start of reorganization ask user in console about path, etc.
# TODO: Manage output to console

#-------------------------------------------------------------------------------
#   Loop through a data structure which was generated by a folder/file scan and
#   holds information about the found files.
#
sub loop_data {
	my $data = shift;       # data structure holding the result of a folder scan
	my $target = shift;     # path info to the common folder double files will
							# be moved to

	my $time_stamp = get_time_stamp();
	my $org_log = './logs/organize_' . $time_stamp . '.log';# create logfile for
															# logging the whole
	open $org_log_fh, ">:encoding(utf8)", $org_log or die   # reorganization
		"Couldnt open organize log $org_log: $!";           # process

	foreach my $key ( keys %$data ) {
		if (scalar @{$data->{$key}} > 1) {
			say scalar@{$data->{$key}} . ' mal: ' . path($data->{$key}->[0]->[0])->basename;
			foreach my $double ( $data->{$key} ) {
				my $cnt = 0;
				foreach my $entry ( @$double ) {
					my $target_filename = make_filename( $entry->[0], $entry->[6] );

					# add the extension to the desitination path
					my $target_ext; # path including folder named acc. to extension
					if ( $entry->[1] ) {
						$target_ext = path($target)->child( lc $entry->[1] );
					}
					else {
						$target_ext = path($target)->child( '_none_' );
					}

					if ($cnt == 0 ) {   # only the first loop copies the file

						# create new folder if it doesn't exist already
						if ( !(-e $target_ext and -d $target_ext) ) {
							path( $target_ext )->mkpath;
						}

						my $copy_stat = copy_file (
							$entry->[0], $target_filename, $target_ext );

						# don't proceed with the whole doublette family if the
						# original file can't be copied
						if ( !$copy_stat ) {
							say $org_log_fh "ERROR: Skipped whole doublette family.";
							last;
						}

						my $shortcut_stat = create_shortcut (
							$entry->[0], $target_filename, $target_ext );

						if ( $copy_stat && $shortcut_stat ) {
							remove_file ( $entry->[0] );
						}

						$cnt ++;
					}
					else {              # all other only create shortcuts
						create_shortcut(
							$entry->[0], $target_filename, $target_ext );
						remove_file( $entry->[0] );
					}
				}
				print "\n";
			}
		}
	}
	close $org_log_fh;
}

#-------------------------------------------------------------------------------
#   Copy original to common folder
#
sub copy_file {
	my $source = shift;         # path and filename of the original file
	my $target_file = shift;    # filename consisting of filename + MD5 checksum
	my $target = shift;         # path to new collective directory

	my $newpath = path($target)->child($target_file);

	say "copy from: " . $source;
	say "copy to  : " . $newpath;

	if ( path($source)->copy($newpath) ) {
		# TODO: presently log message is displayed on console not in file
		say $org_log_fh "SUCCESS COPY: $source|$newpath";
		return 1;
	}
	else {
		say $org_log_fh "ERROR COPY: $source|$newpath";
		return undef;
	}
}

#-------------------------------------------------------------------------------
#   Removes the file
#
sub remove_file {
	my $file = shift;

	say "remove: $file";

	if ( path($file)->remove ) {
		say $org_log_fh "SUCCESS REMOVE: $file";
		return 1;
	}
	else {
		say $org_log_fh "ERROR REMOVE: $file";
		return undef;
	}
}

#-------------------------------------------------------------------------------
#   Creates a shortcut in the directory from which the original file will be
#   removed.
#
sub create_shortcut {
	my $path = shift;           # path and filename of the original file which will be moved
	my $target_file = shift;    # filename consisting of filename + MD5 checksum
	my $target_path = shift;    # path to the destination folder

	# The filename of the original file which provides the name of the short-
	# cut later on
	my $file_name = path($path)->basename;

	# The path to the original folder without the filename. The path is needed to
	# store the shortcut in the original folder.
	my $dir_name = path($path)->parent;

	# Add the 'lnk' extension to the original filename so that the shortcut has
	# the same name as the original file
	my $shortcut_name = $file_name . '.lnk';

	# Add the name of the shortcut to the path to the original folder, so that
	# the shortcut is stored there
	my $shortcut_path = path($dir_name)->child($shortcut_name);

	my $LINK = Win32::Shortcut->new();

	# Add the path to the single file which is now in the common folder as a
	# target of the shortcut
	$LINK->{'Path'} = path($target_path)->child($target_file);
	say "Path to the common file: " . path($target_path)->child($target_file);

	# Saves the shortcut under the given path. That is the location where the
	# original file is deleted respectively moved to the common folder
	if ( $LINK->Save($shortcut_path) ) {
		say $org_log_fh "SUCCESS SHORTCUT: $shortcut_path";
		say "Path and name of link  : " . $shortcut_path;
		# By closing the shortcut the process of creating it is finished
		$LINK->Close();
		return 1;
	}
	else {
		say $org_log_fh "ERROR SHORTCUT: $shortcut_path";
		return undef;
	}
}

#-------------------------------------------------------------------------------
#   Since it is possible to have double filenames with different MD5 sums which
#   have to be copied into a common folder the new filename will be combined
#   from the filename plus the MD checksum e.g.:
#       old name: my_file.txt
#       new name: my_file_0f8ed58339fa224772b43b8925bd955e.txt
#
sub make_filename {
	my $path = shift;   # path and filename of the to be copied file
	my $md5 = shift;    # MD5 checksum of the to be copied file

	# split filename at '.' to get the extension
	my @filecomponents = split ( /\./, path($path)->basename);

	my $filename;
	my $extension;

	if ( scalar @filecomponents > 1 ) {     # file has an extension
		$extension = pop @filecomponents;   # last element in arry is extension
		$filename = join '.', @filecomponents;  # recombine filename
		$filename = $filename . '_' . $md5 . '.' . $extension;
	}
	else {                                  # file doesn't have an extension
		$filename = $filecomponents[0] . '_' . $md5;
	}

	return $filename;
}

1;